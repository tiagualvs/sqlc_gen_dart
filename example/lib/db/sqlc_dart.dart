// GENERATED CODE - DO NOT MODIFY BY HAND
// Generated by sqlc_dart

import 'package:postgres/postgres.dart';

/// Custom exception for SQLC generated code
class SqlcException implements Exception {
  final String message;
  final Object? originalError;
  SqlcException(this.message, [this.originalError]);
  @override
  String toString() => 'SqlcException: $message ${originalError != null ? "($originalError)" : ""}';
}

class Uuid implements Comparable<Uuid> {
  final String _value;

  Uuid(this._value) {
    if (!RegExp(r'^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$').hasMatch(_value)) {
      throw FormatException('Invalid UUID: $_value');
    }
  }

  @override
  String toString() => _value;

  @override
  int compareTo(covariant Uuid other) {
    return _value.compareTo(other._value);
  }
}
/// Main class for managing database connection and queries
class SqlcDart {
  late final Queries queries;

  SqlcDart(String connectionUrl) {
    Uri uri = Uri.parse(connectionUrl);
    if (!uri.queryParameters.containsKey('max_connection_count')) {
      uri = uri.replace(queryParameters: {...uri.queryParameters, 'max_connection_count': 10});
    }
    if (!uri.queryParameters.containsKey('max_connection_age')) {
      uri = uri.replace(queryParameters: {...uri.queryParameters, 'max_connection_age': 3600});
    }
    queries = Queries(Pool.withUrl(uri.toString()));
  }
}

class User {
  final Uuid id;
  final String name;
  final String username;
  final String email;
  final String password;
  final DateTime? createdAt;
  final DateTime? updatedAt;

  const User({required this.id, required this.name, required this.username, required this.email, required this.password, this.createdAt, this.updatedAt});

  factory User.fromMap(Map<String, dynamic> map) {
    return User(
      id: Uuid(map['id'] as String),
      name: map['name'] as String,
      username: map['username'] as String,
      email: map['email'] as String,
      password: map['password'] as String,
      createdAt: map['created_at'] != null ? DateTime.parse(map['created_at'] as String) : null,
      updatedAt: map['updated_at'] != null ? DateTime.parse(map['updated_at'] as String) : null,
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'id': id.toString(),
      'name': name,
      'username': username,
      'email': email,
      'password': password,
      'created_at': createdAt?.toIso8601String(),
      'updated_at': updatedAt?.toIso8601String(),
    };
  }
}

class Chat {
  final Uuid id;
  final String? name;
  final String type;
  final Uuid userId;
  final DateTime? createdAt;
  final DateTime? updatedAt;

  const Chat({required this.id, this.name, required this.type, required this.userId, this.createdAt, this.updatedAt});

  factory Chat.fromMap(Map<String, dynamic> map) {
    return Chat(
      id: Uuid(map['id'] as String),
      name: map['name'] as String?,
      type: map['type'] as String,
      userId: Uuid(map['user_id'] as String),
      createdAt: map['created_at'] != null ? DateTime.parse(map['created_at'] as String) : null,
      updatedAt: map['updated_at'] != null ? DateTime.parse(map['updated_at'] as String) : null,
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'id': id.toString(),
      'name': name,
      'type': type,
      'user_id': userId.toString(),
      'created_at': createdAt?.toIso8601String(),
      'updated_at': updatedAt?.toIso8601String(),
    };
  }
}

class Participant {
  final Uuid userId;
  final Uuid chatId;
  final DateTime? createdAt;

  const Participant({required this.userId, required this.chatId, this.createdAt});

  factory Participant.fromMap(Map<String, dynamic> map) {
    return Participant(
      userId: Uuid(map['user_id'] as String),
      chatId: Uuid(map['chat_id'] as String),
      createdAt: map['created_at'] != null ? DateTime.parse(map['created_at'] as String) : null,
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'user_id': userId.toString(),
      'chat_id': chatId.toString(),
      'created_at': createdAt?.toIso8601String(),
    };
  }
}

class Message {
  final Uuid id;
  final Uuid chatId;
  final Uuid userId;
  final String content;
  final String type;
  final DateTime? createdAt;
  final DateTime? updatedAt;

  const Message({required this.id, required this.chatId, required this.userId, required this.content, required this.type, this.createdAt, this.updatedAt});

  factory Message.fromMap(Map<String, dynamic> map) {
    return Message(
      id: Uuid(map['id'] as String),
      chatId: Uuid(map['chat_id'] as String),
      userId: Uuid(map['user_id'] as String),
      content: map['content'] as String,
      type: map['type'] as String,
      createdAt: map['created_at'] != null ? DateTime.parse(map['created_at'] as String) : null,
      updatedAt: map['updated_at'] != null ? DateTime.parse(map['updated_at'] as String) : null,
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'id': id.toString(),
      'chat_id': chatId.toString(),
      'user_id': userId.toString(),
      'content': content,
      'type': type,
      'created_at': createdAt?.toIso8601String(),
      'updated_at': updatedAt?.toIso8601String(),
    };
  }
}

class Queries {
  final Pool _db;

  Queries(this._db);

  Future<User> insertUser({required String name, required String username, required String email, required String password}) async {
    const sql = r'''INSERT INTO
    users (
        name,
        username,
        email,
        password
    )
VALUES (
        $1,
        $2,
        $3,
        $4
    )
RETURNING
    id, name, username, email, password, created_at, updated_at''';
    try {
      final result = await _db.execute(Sql.indexed(sql), parameters: [name, username, email, password]);
      if (result.isEmpty) {
        throw SqlcException('No results found for query insertUser');
      }
      final row = result.first.toColumnMap();
      return User.fromMap(row);
    } on SqlcException {
      rethrow;
    } on PgException catch (e) {
      throw SqlcException(e.runtimeType.toString(), e);
    } on Exception catch (e) {
      throw SqlcException(e.runtimeType.toString(), e);
    }
  }

  Future<User> getUserById({required Uuid id}) async {
    const sql = r'''SELECT id, name, username, email, password, created_at, updated_at FROM users WHERE id = $1 LIMIT 1''';
    try {
      final result = await _db.execute(Sql.indexed(sql), parameters: [id]);
      if (result.isEmpty) {
        throw SqlcException('No results found for query getUserById');
      }
      final row = result.first.toColumnMap();
      return User.fromMap(row);
    } on SqlcException {
      rethrow;
    } on PgException catch (e) {
      throw SqlcException(e.runtimeType.toString(), e);
    } on Exception catch (e) {
      throw SqlcException(e.runtimeType.toString(), e);
    }
  }

  Future<User> getUserByUsername({required String username}) async {
    const sql = r'''SELECT id, name, username, email, password, created_at, updated_at FROM users WHERE username = $1 LIMIT 1''';
    try {
      final result = await _db.execute(Sql.indexed(sql), parameters: [username]);
      if (result.isEmpty) {
        throw SqlcException('No results found for query getUserByUsername');
      }
      final row = result.first.toColumnMap();
      return User.fromMap(row);
    } on SqlcException {
      rethrow;
    } on PgException catch (e) {
      throw SqlcException(e.runtimeType.toString(), e);
    } on Exception catch (e) {
      throw SqlcException(e.runtimeType.toString(), e);
    }
  }

  Future<User> getUserByEmail({required String email}) async {
    const sql = r'''SELECT id, name, username, email, password, created_at, updated_at FROM users WHERE email = $1 LIMIT 1''';
    try {
      final result = await _db.execute(Sql.indexed(sql), parameters: [email]);
      if (result.isEmpty) {
        throw SqlcException('No results found for query getUserByEmail');
      }
      final row = result.first.toColumnMap();
      return User.fromMap(row);
    } on SqlcException {
      rethrow;
    } on PgException catch (e) {
      throw SqlcException(e.runtimeType.toString(), e);
    } on Exception catch (e) {
      throw SqlcException(e.runtimeType.toString(), e);
    }
  }

  Future<List<User>> listUsers() async {
    const sql = r'''SELECT id, name, username, email, password, created_at, updated_at FROM users ORDER BY name''';
    try {
      final result = await _db.execute(sql);
      return result.map((row) => User.fromMap(row.toColumnMap())).toList();
    } on SqlcException {
      rethrow;
    } on PgException catch (e) {
      throw SqlcException(e.runtimeType.toString(), e);
    } on Exception catch (e) {
      throw SqlcException(e.runtimeType.toString(), e);
    }
  }

  Future<void> updateUser({required Uuid id, required String name, required String username, required String email, required String password}) async {
    const sql = r'''UPDATE users
set
    name = coalesce($2, name),
    username = coalesce($3, username),
    email = coalesce($4, email),
    password = coalesce($5, password)
WHERE
    id = $1''';
    try {
      await _db.execute(Sql.indexed(sql), parameters: [id, name, username, email, password]);
    } on PgException catch (e) {
      throw SqlcException(e.runtimeType.toString(), e);
    } on Exception catch (e) {
      throw SqlcException(e.runtimeType.toString(), e);
    }
  }

  Future<void> deleteUser({required Uuid id}) async {
    const sql = r'''DELETE FROM users WHERE id = $1''';
    try {
      await _db.execute(Sql.indexed(sql), parameters: [id]);
    } on PgException catch (e) {
      throw SqlcException(e.runtimeType.toString(), e);
    } on Exception catch (e) {
      throw SqlcException(e.runtimeType.toString(), e);
    }
  }

}
